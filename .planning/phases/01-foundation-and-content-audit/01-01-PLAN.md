---
phase: 01-foundation-and-content-audit
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - astro.config.mjs
  - package.json
  - tailwind.config.mjs
  - src/env.d.ts
  - src/pages/index.astro
  - .gitignore
  - .netlify/state.json
autonomous: true
requirements:
  - MIGR-01

must_haves:
  truths:
    - "A staging URL on Netlify (*.netlify.app) is live and accessible"
    - "Pushing a commit to main triggers an automatic Netlify deploy"
    - "The Astro project builds without errors locally and on Netlify CI"
  artifacts:
    - path: "astro.config.mjs"
      provides: "Astro 5.x project configuration"
      contains: "defineConfig"
    - path: "package.json"
      provides: "Project dependencies including astro and @astrojs/tailwind"
      contains: "\"astro\""
    - path: "src/pages/index.astro"
      provides: "Minimal home page so the build succeeds"
      min_lines: 5
    - path: ".netlify/state.json"
      provides: "Netlify CLI site link (siteId)"
      contains: "siteId"
  key_links:
    - from: "GitHub repo main branch"
      to: "Netlify deploy"
      via: "Netlify GitHub integration webhook"
      pattern: "Netlify deploy triggered on push"
    - from: "astro.config.mjs"
      to: "Netlify build"
      via: "build command: astro build, publish dir: dist"
      pattern: "output.*static|build.*astro"
---

<objective>
Initialize the Astro 5.x project, push to a GitHub repository, and connect to Netlify to get a live staging URL. This is the foundation all subsequent phases build on — no design or content work can begin until CI/CD is live.

Purpose: Establish the build pipeline so every code change in later phases auto-deploys to a preview URL.
Output: A GitHub repo with a minimal Astro 5 project and a live `*.netlify.app` staging URL that auto-deploys on push.
</objective>

<execution_context>
@/Users/carolyn/.claude/get-shit-done/workflows/execute-plan.md
@/Users/carolyn/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-and-content-audit/01-CONTEXT.md
@.planning/phases/01-foundation-and-content-audit/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Astro 5.x project with Tailwind 4.x and push to GitHub</name>
  <files>
    astro.config.mjs
    package.json
    tailwind.config.mjs
    src/env.d.ts
    src/pages/index.astro
    .gitignore
  </files>
  <action>
Initialize an Astro 5.x project in the current directory (/Users/carolyn/Gaslight) using the Astro CLI:

```bash
npm create astro@latest . -- --template minimal --install --no-git
```

Then add Tailwind CSS 4.x integration. Astro 5 uses the `@astrojs/tailwind` integration but Tailwind 4 uses a CSS-first config (no `tailwind.config.js` file — instead configure via `@import "tailwindcss"` in CSS). Install:

```bash
npx astro add tailwind
```

When prompted about config format, select the CSS-first approach for Tailwind 4.x (i.e., do NOT generate a `tailwind.config.js` file — Tailwind 4 is configured in CSS). If the integration wizard creates a `tailwind.config.mjs`, that is fine to keep for the `@astrojs/tailwind` integration options, but do NOT add any theme extension content to it yet (that is Phase 2 work).

Update `src/pages/index.astro` to a minimal placeholder:
```astro
---
// Gaslight Conversions — placeholder index
---
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width" />
    <title>Gaslight Conversions — Coming Soon</title>
  </head>
  <body>
    <h1>Gaslight Conversions</h1>
    <p>Site under construction.</p>
  </body>
</html>
```

Create a `.gitignore` that includes at minimum:
```
node_modules/
dist/
.env
.env.*
!.env.example
.netlify/
```

Initialize git and push to GitHub using the GitHub CLI:
```bash
git init
git add .
git commit -m "chore(01-01): initialize Astro 5.x project with Tailwind 4.x"
gh repo create gaslight-conversions --public --source=. --remote=origin --push
```

If `gh` is not authenticated, it will prompt for login — follow the browser flow.

Note: Do NOT install `netlify-cli` globally yet — that is Task 2.
  </action>
  <verify>
    <automated>cd /Users/carolyn/Gaslight && npm run build 2>&1 | tail -5</automated>
    <manual>Confirm `dist/index.html` exists after build. Confirm GitHub repo is visible at github.com/[username]/gaslight-conversions.</manual>
    <sampling_rate>run after this task completes, before Task 2</sampling_rate>
  </verify>
  <done>
    `npm run build` completes with exit code 0 and produces `dist/index.html`. Git history shows one commit. GitHub remote exists and is accessible.
  </done>
</task>

<task type="auto">
  <name>Task 2: Connect to Netlify via CLI and verify staging URL is live</name>
  <files>
    .netlify/state.json
  </files>
  <action>
Install the Netlify CLI globally and link the project to a new Netlify site:

```bash
npm install -g netlify-cli
netlify login
netlify init
```

When `netlify init` prompts:
- "What would you like to do?" → Select "Create & configure a new site"
- Team: select the available team (Carolyn's personal team)
- Site name: enter `gaslight-conversions` (or accept auto-generated name if taken)
- Build command: `astro build`
- Publish directory: `dist`

After init completes, trigger a manual deploy to confirm the pipeline works:
```bash
netlify deploy --build --prod
```

Record the resulting `*.netlify.app` URL. Add the staging URL to STATE.md under `## Accumulated Context → Decisions`:

```
- Staging URL: https://[site-name].netlify.app (connected to GitHub main branch)
```

Also update `STATE.md` to note:
- Netlify site name
- Auto-deploy is configured (pushes to `main` trigger deploys)

Note: `netlify login` opens a browser for OAuth — this is expected. If running in a non-interactive environment, run `netlify login` separately first and retry `netlify init` after authentication succeeds.
  </action>
  <verify>
    <automated>curl -s -o /dev/null -w "%{http_code}" $(netlify status --json 2>/dev/null | node -e "const d=require('fs').readFileSync('/dev/stdin','utf8');try{console.log(JSON.parse(d).siteData.ssl_url)}catch(e){console.log('parse-error')}" 2>/dev/null) 2>/dev/null || echo "check .netlify/state.json exists"</automated>
    <manual>
      1. Visit the staging URL in a browser — should show "Gaslight Conversions — Coming Soon" heading.
      2. Push a trivial change (`git commit --allow-empty -m "test deploy" && git push`) and confirm a new deploy appears in the Netlify dashboard under Deploys.
    </manual>
    <sampling_rate>run after this task completes</sampling_rate>
  </verify>
  <done>
    `.netlify/state.json` exists and contains a `siteId`. The staging URL (*.netlify.app) returns HTTP 200. STATE.md records the staging URL.
  </done>
</task>

</tasks>

<verification>
- `npm run build` completes with exit code 0
- `dist/index.html` exists after build
- `.netlify/state.json` exists with a valid `siteId`
- Staging URL (`*.netlify.app`) returns HTTP 200
- GitHub repo exists with CI/CD configured (push triggers Netlify deploy)
</verification>

<success_criteria>
- A `*.netlify.app` staging URL is live and serves the placeholder Astro page
- Pushing to `main` on GitHub automatically triggers a Netlify deploy
- No build errors locally or in Netlify CI
- STATE.md updated with staging URL
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-and-content-audit/01-01-SUMMARY.md` using the summary template. Record: staging URL, GitHub repo URL, Netlify site name, build command, publish directory.
</output>
